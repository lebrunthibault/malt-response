---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/trpc/init.ts
  - src/trpc/routers/_app.ts
  - src/trpc/routers/health.ts
  - src/trpc/client.tsx
  - src/trpc/server.tsx
  - src/trpc/query-client.ts
  - src/app/api/trpc/[trpc]/route.ts
  - src/app/layout.tsx
  - supabase/migrations/001_initial_schema.sql
autonomous: true

must_haves:
  truths:
    - "tRPC health.check returns { status: 'ok', database: 'connected' } when called"
    - "tRPC works from both server components (prefetch) and client components (hooks)"
    - "All 5 database tables exist with RLS enabled"
    - "Profile is auto-created when a user signs up (trigger fires)"
    - "Storage bucket user-documents exists with per-user folder policies"
    - "Rate limit function check_rate_limit is callable"
  artifacts:
    - path: "src/trpc/init.ts"
      provides: "tRPC initialization with superjson and Supabase context"
      exports: ["createTRPCRouter", "baseProcedure", "authedProcedure", "createTRPCContext"]
    - path: "src/trpc/routers/_app.ts"
      provides: "Root router merging all sub-routers"
      exports: ["appRouter", "AppRouter"]
    - path: "src/trpc/client.tsx"
      provides: "TRPCReactProvider and useTRPC hook for client components"
      exports: ["TRPCReactProvider", "useTRPC"]
    - path: "src/trpc/server.tsx"
      provides: "Server-side tRPC caller and prefetch proxy"
      exports: ["trpc", "getQueryClient", "caller"]
    - path: "src/app/api/trpc/[trpc]/route.ts"
      provides: "HTTP handler for tRPC requests"
      exports: ["GET", "POST"]
    - path: "supabase/migrations/001_initial_schema.sql"
      provides: "Complete database schema with all 5 tables, RLS, triggers, functions, storage"
      contains: "ENABLE ROW LEVEL SECURITY"
  key_links:
    - from: "src/trpc/init.ts"
      to: "src/lib/supabase/server.ts"
      via: "createTRPCContext calls createClient()"
      pattern: "createClient"
    - from: "src/trpc/client.tsx"
      to: "src/app/api/trpc/[trpc]/route.ts"
      via: "httpBatchLink with /api/trpc URL"
      pattern: "api/trpc"
    - from: "src/app/layout.tsx"
      to: "src/trpc/client.tsx"
      via: "TRPCReactProvider wrapping children"
      pattern: "TRPCReactProvider"
    - from: "src/trpc/routers/health.ts"
      to: "Supabase database"
      via: "ctx.supabase query to profiles table"
      pattern: "supabase.*from.*profiles"
---

<objective>
Set up tRPC v11 with server-side prefetching, client hooks, and a health check procedure. Create the complete database schema with all 5 tables, RLS policies, triggers, and storage bucket. Wire the root layout with TRPCReactProvider.

Purpose: Establish the type-safe API layer and database foundation. tRPC is the backbone for all feature development in later phases. The schema defines the data model for the entire application.
Output: Working tRPC API with health check, TRPCProvider in root layout, complete database migration SQL ready to apply.
</objective>

<execution_context>
@/home/thibault/.claude/get-shit-done/workflows/execute-plan.md
@/home/thibault/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tRPC v11 infrastructure and wire into root layout</name>
  <files>
    src/trpc/init.ts
    src/trpc/routers/_app.ts
    src/trpc/routers/health.ts
    src/trpc/client.tsx
    src/trpc/server.tsx
    src/trpc/query-client.ts
    src/app/api/trpc/[trpc]/route.ts
    src/app/layout.tsx
  </files>
  <action>
    Create all tRPC files following the EXACT patterns from RESEARCH.md. Every code example is verified against tRPC v11 official docs.

    1. src/trpc/query-client.ts:
       - Export makeQueryClient() returning new QueryClient
       - staleTime: 30 * 1000
       - dehydrate.shouldDehydrateQuery: default OR pending status

    2. src/trpc/init.ts:
       - Import cache from 'react'
       - Import createClient from '@/lib/supabase/server'
       - Export createTRPCContext (cached, async): creates Supabase server client, gets user via getUser()
       - initTRPC with context type and transformer: superjson
       - Export createTRPCRouter, createCallerFactory, baseProcedure
       - Export authedProcedure: uses .use() middleware that throws UNAUTHORIZED if !ctx.user, narrows ctx.user to non-null

    3. src/trpc/server.tsx:
       - Import 'server-only' first
       - Import createTRPCOptionsProxy from '@trpc/tanstack-react-query'
       - Export getQueryClient (cached makeQueryClient)
       - Export trpc (createTRPCOptionsProxy with ctx, router, queryClient)
       - Export caller (appRouter.createCaller with createTRPCContext)

    4. src/trpc/client.tsx:
       - 'use client' directive
       - Import createTRPCContext from '@trpc/tanstack-react-query' (NOT from init.ts -- this is a different function)
       - Export { TRPCProvider, useTRPC } from createTRPCContext<AppRouter>()
       - Browser query client singleton pattern
       - getUrl() helper (empty base on client, VERCEL_URL on server, localhost fallback)
       - Export TRPCReactProvider component wrapping QueryClientProvider + TRPCProvider with httpBatchLink
       - CRITICAL: transformer: superjson on httpBatchLink (must match init.ts)

    5. src/trpc/routers/health.ts:
       - Import baseProcedure and createTRPCRouter from '../init'
       - Export healthRouter with check procedure (query)
       - Queries supabase from('profiles').select('count').limit(0)
       - Returns { status: 'ok', database: error ? 'error' : 'connected', auth: user state, timestamp: new Date() }

    6. src/trpc/routers/_app.ts:
       - Import createTRPCRouter
       - Import healthRouter
       - Export appRouter = createTRPCRouter({ health: healthRouter })
       - Export type AppRouter = typeof appRouter

    7. src/app/api/trpc/[trpc]/route.ts:
       - Import fetchRequestHandler from '@trpc/server/adapters/fetch'
       - Import createTRPCContext and appRouter
       - Create handler function
       - Export handler as GET and POST

    8. Update src/app/layout.tsx:
       - Import TRPCReactProvider from '@/trpc/client'
       - Set lang="fr" on html tag
       - Set metadata: title "MaltResponse", description "Generez des reponses Malt personnalisees"
       - Wrap {children} in TRPCReactProvider
       - Keep existing body className from shadcn init (antialiased, font classes)

    ANTI-PATTERNS TO AVOID:
    - Do NOT use @trpc/next (Pages Router only)
    - Do NOT use createTRPCProxyClient (v10, use createTRPCClient)
    - Do NOT import createTRPCContext from init.ts in client.tsx (it's a different createTRPCContext from @trpc/tanstack-react-query)
    - Do NOT forget superjson on BOTH initTRPC.create() AND httpBatchLink
  </action>
  <verify>
    Run `npm run build` to confirm no TypeScript errors. Then start dev server and visit http://localhost:3000/api/trpc/health.check to confirm tRPC responds (should return JSON with status).
  </verify>
  <done>
    tRPC v11 is fully wired: init with superjson + Supabase context, server-side prefetch proxy, client-side hooks with TRPCProvider, HTTP handler at /api/trpc, health check procedure returns status. Root layout wraps app in TRPCReactProvider.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database schema migration with all tables, RLS, triggers, and storage</name>
  <files>
    supabase/migrations/001_initial_schema.sql
  </files>
  <action>
    Create supabase/migrations/001_initial_schema.sql containing the COMPLETE database schema from RESEARCH.md. This is a single migration file that sets up all 5 tables, their RLS policies, the auto-profile trigger, the rate limit function, and the storage bucket.

    The SQL must include (in order):

    1. **profiles table**: id (UUID PK referencing auth.users), email, display_name, is_admin (default false), is_disabled (default false), daily_generation_count (default 0), last_generation_date, created_at, updated_at. RLS enabled. Policies: users view own, users update own.

    2. **handle_new_user() trigger function**: SECURITY DEFINER, inserts into profiles on auth.users INSERT. Trigger on_auth_user_created.

    3. **documents table**: id (UUID PK gen_random_uuid), user_id (FK profiles), doc_type (CHECK IN cv/past_response/profile_info/other), file_name, file_path, mime_type, file_size_bytes, extracted_text (nullable), extraction_status (CHECK IN pending/processing/completed/failed, default pending), created_at, updated_at. Indexes on user_id and (user_id, doc_type). RLS: select/insert/delete own.

    4. **job_offers table**: id, user_id (FK profiles), title, description (NOT NULL), company_name, company_description, company_website, created_at. Index on user_id. RLS: ALL own (select/insert/update/delete).

    5. **responses table**: id, user_id (FK profiles), job_offer_id (FK job_offers), generated_text, model_used, input_tokens, output_tokens, generation_time_ms, created_at. Indexes on user_id and job_offer_id. RLS: select own, insert own.

    6. **generation_logs table**: id, user_id (FK profiles), generation_date (DATE default CURRENT_DATE), count (default 1), created_at. UNIQUE(user_id, generation_date). Index on (user_id, generation_date). RLS: select own.

    7. **check_rate_limit() function**: SECURITY DEFINER, takes p_user_id UUID, p_date DATE, p_max_count INTEGER. Uses INSERT ON CONFLICT DO UPDATE (atomic). Returns JSONB { allowed, remaining }. Rolls back increment if over limit.

    8. **Storage bucket**: INSERT into storage.buckets for 'user-documents' (private). Policies for upload/view/delete own files (folder path matches auth.uid()).

    NOTE: This SQL file is a reference migration. It will be applied to Supabase either via the Supabase CLI (`supabase db push`) or manually via the SQL Editor in the Supabase Dashboard. Do NOT attempt to run it programmatically from Next.js.

    Add a header comment: "-- MaltResponse initial schema -- Apply via: Supabase Dashboard > SQL Editor, or supabase db push"
  </action>
  <verify>
    Validate the SQL syntax by reviewing the file. Confirm all 5 tables are present, all have ENABLE ROW LEVEL SECURITY, all have at least one policy. Confirm the trigger, the rate limit function, and the storage bucket are included. If Supabase CLI is available, run `supabase db push --dry-run` to validate.
  </verify>
  <done>
    Complete database migration file exists at supabase/migrations/001_initial_schema.sql with all 5 tables (profiles, documents, job_offers, responses, generation_logs), RLS enabled on each, auto-profile trigger, atomic rate limit function, and user-documents storage bucket with per-user folder policies.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with tRPC files and root layout changes
2. GET http://localhost:3000/api/trpc/health.check returns JSON response
3. supabase/migrations/001_initial_schema.sql contains all 5 CREATE TABLE statements
4. All 5 tables have ALTER TABLE ... ENABLE ROW LEVEL SECURITY
5. handle_new_user trigger function exists
6. check_rate_limit function exists
7. Storage bucket 'user-documents' creation exists
8. Root layout wraps children in TRPCReactProvider
</verification>

<success_criteria>
- tRPC v11 health check responds at /api/trpc/health.check
- Root layout uses TRPCReactProvider with superjson transformer
- Server-side prefetch proxy (trpc) and caller are exported from server.tsx
- Client-side useTRPC hook is exported from client.tsx
- authedProcedure throws UNAUTHORIZED when no user in context
- Database migration SQL is complete and syntactically valid
- All tables have RLS enabled with appropriate policies
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
